// services/ShareServiceWeb.ts
// ì›¹ í™˜ê²½ ì•ˆì „í•œ íƒ€ë¡œ ì ê´˜ ê³µìœ  ê¸°ëŠ¥ ì„œë¹„ìŠ¤
// ì‘ì„±ì¼: 2024-12-28

import { supabase } from './supabase';
import type { TarotCard } from '../types/tarot';

// DailyInterpretation ì¸í„°í˜ì´ìŠ¤ ì •ì˜
export interface DailyInterpretation {
  fortuneIndex?: {
    overall: number;
    love: number;
    money: number;
    health: number;
    work: number;
  };
  detailedFortune?: {
    mainMessage: string;
    keyPoint?: string;
    advice?: string;
  };
  luckyItems?: {
    color: string;
    number: number;
  };
}

// Reading ì¸í„°í˜ì´ìŠ¤ ì •ì˜
export interface Reading {
  id?: string;
  userId?: string;
  spreadId: string;
  cards: Array<{
    cardNumber?: number;
    number?: number;
    nameKr?: string;
    name_kr?: string;
    name: string;
    orientation: 'upright' | 'reversed';
    position?: {
      index: number;
      name: string;
    };
  }>;
  customQuestion?: string;
  overallMessage?: string;
  aiInterpretation?: string;
  createdAt?: Date;
}

// ê³µìœ  ë°ì´í„° ì¸í„°í˜ì´ìŠ¤
export interface SharedReading {
  id: string;
  createdAt: Date;
  expiresAt: Date;
  spreadType: string;
  cards: Array<{
    cardNumber: number;
    nameKr: string;
    name: string;
    orientation: 'upright' | 'reversed';
    position?: {
      index: number;
      name: string;
    };
  }>;
  customQuestion?: string;
  basicInterpretation?: string;
  aiInterpretation?: string;
  sharedBy?: string;
  viewCount: number;
}

// ì˜¤ëŠ˜ì˜ ì¹´ë“œ ê³µìœ  ë°ì´í„° ì¸í„°í˜ì´ìŠ¤
export interface DailyCardShareData {
  card: TarotCard;
  interpretation: DailyInterpretation;
  date: Date;
}

export class ShareServiceWeb {
  private baseUrl: string;
  private capacitorShare: any = null;
  private capacitor: any = null;

  constructor() {
    // í™˜ê²½ì— ë”°ë¼ URL ì„¤ì •
    this.baseUrl = import.meta.env.VITE_APP_URL || 
                   (import.meta.env.DEV ? 'http://localhost:8082' : 'https://your-app.vercel.app');
    
    // Capacitor í”ŒëŸ¬ê·¸ì¸ ë¹„ë™ê¸° ë¡œë“œ (ì—ëŸ¬ ë¬´ì‹œ)
    this.loadCapacitorPlugins();
  }

  private async loadCapacitorPlugins() {
    try {
      // ë™ì  importë¡œ Capacitor í”ŒëŸ¬ê·¸ì¸ ë¡œë“œ
      const [capacitorCore, capacitorShare] = await Promise.all([
        import('@capacitor/core').catch(() => null),
        import('@capacitor/share').catch(() => null)
      ]);
      
      if (capacitorCore) {
        this.capacitor = capacitorCore.Capacitor;
      }
      if (capacitorShare) {
        this.capacitorShare = capacitorShare.Share;
      }
    } catch (error) {
      // ì›¹ í™˜ê²½ì—ì„œëŠ” ì—ëŸ¬ ë¬´ì‹œ
      console.log('Capacitor plugins not available in web environment');
    }
  }

  /**
   * ì¼ë°˜ ì ê´˜ ê²°ê³¼ë¥¼ ê³µìœ  ê°€ëŠ¥í•œ ë§í¬ë¡œ ìƒì„±
   */
  async createShareLink(reading: Reading): Promise<string> {
    try {
      // 1. ê³µìœ  ë°ì´í„° ì¤€ë¹„
      const shareData = {
        spread_type: reading.spreadId,
        cards: reading.cards.map(card => ({
          cardNumber: card.cardNumber || card.number || 0,
          nameKr: card.nameKr || card.name_kr || '',
          name: card.name || '',
          orientation: card.orientation || 'upright',
          position: card.position
        })),
        custom_question: reading.customQuestion || null,
        basic_interpretation: reading.overallMessage || null,
        ai_interpretation: reading.aiInterpretation || null,
        shared_by: reading.userId || null
      };
      
      console.log('Creating share link with data:', shareData);
      
      // 2. Supabaseì— ì €ì¥
      const { data, error } = await supabase
        .from('shared_readings')
        .insert(shareData)
        .select('id')
        .single();
      
      if (error) {
        console.error('Error creating share:', error);
        throw error;
      }
      
      // 3. ê³µìœ  URL ìƒì„±
      const shareUrl = `${this.baseUrl}/share/${data.id}`;
      console.log('Share URL created:', shareUrl);
      
      return shareUrl;
      
    } catch (error) {
      console.error('ê³µìœ  ë§í¬ ìƒì„± ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  /**
   * ì˜¤ëŠ˜ì˜ ì¹´ë“œë¥¼ ê³µìœ  ê°€ëŠ¥í•œ ë§í¬ë¡œ ìƒì„±
   */
  async createDailyCardShareLink(data: DailyCardShareData): Promise<string> {
    try {
      // ì˜¤ëŠ˜ì˜ ì¹´ë“œìš© ê³µìœ  ë°ì´í„°
      const shareData = {
        spread_type: 'daily_card',
        cards: [{
          cardNumber: data.card.number,
          nameKr: data.card.name_kr,
          name: data.card.name,
          orientation: 'upright' as const,
          position: null
        }],
        custom_question: null,
        basic_interpretation: this.formatDailyInterpretation(data.interpretation),
        ai_interpretation: null,
        shared_by: null
      };
      
      const { data: sharedData, error } = await supabase
        .from('shared_readings')
        .insert(shareData)
        .select('id')
        .single();
      
      if (error) throw error;
      
      return `${this.baseUrl}/share/${sharedData.id}`;
      
    } catch (error) {
      console.error('ì˜¤ëŠ˜ì˜ ì¹´ë“œ ê³µìœ  ë§í¬ ìƒì„± ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  /**
   * ê³µìœ  ë©”ì‹œì§€ ìƒì„±
   */
  generateShareMessage(reading: Reading, shareUrl: string): string {
    let message = 'ğŸ”® íƒ€ë¡œ ì ê´˜ ê²°ê³¼ë¥¼ ê³µìœ í•©ë‹ˆë‹¤\n\n';
    
    // ì»¤ìŠ¤í…€ ì§ˆë¬¸ì´ ìˆìœ¼ë©´ í¬í•¨
    if (reading.customQuestion) {
      message += `â“ ì§ˆë¬¸: ${reading.customQuestion}\n\n`;
    }
    
    // ìŠ¤í”„ë ˆë“œ íƒ€ì…
    const spreadNames: Record<string, string> = {
      'one_card': 'ì› ì¹´ë“œ',
      'three_card_timeline': 'ì‹œê°„ì˜ íë¦„ (3ì¥)',
      'celtic_cross': 'ì¼ˆí‹± í¬ë¡œìŠ¤ (10ì¥)'
    };
    message += `ğŸ“‹ ë°°ì—´ë²•: ${spreadNames[reading.spreadId] || reading.spreadId}\n\n`;
    
    // ë½‘ì€ ì¹´ë“œë“¤
    message += 'ğŸ´ ë½‘ì€ ì¹´ë“œ:\n';
    reading.cards.forEach((card, index) => {
      const position = card.position?.name || this.getPositionName(reading.spreadId, index);
      const orientation = card.orientation === 'reversed' ? '(ì—­)' : '';
      message += `${index + 1}. ${position}: ${card.nameKr || card.name}${orientation}\n`;
    });
    
    message += `\nğŸ‘‰ ìì„¸í•œ í•´ì„ ë³´ê¸°\n${shareUrl}\n\n`;
    message += 'ğŸ¯ ë‚˜ë§Œì˜ íƒ€ë¡œ - ë§¤ì¼ ë¬´ë£Œ íƒ€ë¡œ ì ';
    
    return message;
  }

  /**
   * ì˜¤ëŠ˜ì˜ ì¹´ë“œ ê³µìœ  ë©”ì‹œì§€ ìƒì„±
   */
  generateDailyCardShareMessage(
    card: TarotCard, 
    interpretation: DailyInterpretation, 
    shareUrl: string
  ): string {
    let message = `ğŸ”® ì˜¤ëŠ˜ì˜ íƒ€ë¡œ ì¹´ë“œ\n\n`;
    message += `ğŸ´ ${card.name_kr}\n\n`;
    
    // ìš´ì„¸ ì§€ìˆ˜
    if (interpretation?.fortuneIndex) {
      message += `ğŸ“Š ì˜¤ëŠ˜ì˜ ìš´ì„¸\n`;
      const fi = interpretation.fortuneIndex;
      message += `ì „ì²´ìš´: ${'â­'.repeat(fi.overall)}\n`;
      message += `ì• ì •ìš´: ${'â­'.repeat(fi.love)}\n`;
      message += `ê¸ˆì „ìš´: ${'â­'.repeat(fi.money)}\n`;
      message += `ê±´ê°•ìš´: ${'â­'.repeat(fi.health)}\n\n`;
    }
    
    // ì£¼ìš” ë©”ì‹œì§€
    if (interpretation?.detailedFortune) {
      message += `ğŸ’« ${interpretation.detailedFortune.mainMessage}\n\n`;
    }
    
    // í–‰ìš´ ì•„ì´í…œ
    if (interpretation?.luckyItems) {
      message += `ğŸ€ í–‰ìš´ì˜ ì•„ì´í…œ\n`;
      message += `ìƒ‰ìƒ: ${interpretation.luckyItems.color} | `;
      message += `ìˆ«ì: ${interpretation.luckyItems.number}\n\n`;
    }
    
    // ë§í¬
    message += `ğŸ‘‰ ìƒì„¸ ìš´ì„¸ ë³´ê¸°\n${shareUrl}\n\n`;
    message += `ğŸ¯ ë§¤ì¼ ë¬´ë£Œ íƒ€ë¡œ - ë‚˜ë§Œì˜ íƒ€ë¡œ`;
    
    return message;
  }

  /**
   * ë„¤ì´í‹°ë¸Œ ê³µìœ  ì‹¤í–‰
   */
  async shareWithNative(title: string, text: string, url: string): Promise<boolean> {
    try {
      // 1. Capacitor ë„¤ì´í‹°ë¸Œ í™˜ê²½ ì²´í¬
      if (this.capacitor?.isNativePlatform?.() && this.capacitorShare) {
        await this.capacitorShare.share({
          title: title,
          text: text,
          url: url,
          dialogTitle: 'ê³µìœ í•˜ê¸°'
        });
        return true;
      }
      
      // 2. Web Share API ì§€ì› ì²´í¬
      if (navigator.share) {
        await navigator.share({
          title: title,
          text: text,
          url: url
        });
        return true;
      }
      
      // 3. í´ë¦½ë³´ë“œ ë³µì‚¬ (í´ë°±)
      const fullText = `${title}\n\n${text}\n\n${url}`;
      await navigator.clipboard.writeText(fullText);
      
      // alert ëŒ€ì‹  return falseë¡œ ì²˜ë¦¬í•˜ì—¬ ìƒìœ„ì—ì„œ showAlert í˜¸ì¶œ
      console.log('Link copied to clipboard');
      return false; // í´ë¦½ë³´ë“œ ë³µì‚¬ëŠ” false ë°˜í™˜
      
    } catch (error) {
      console.error('ê³µìœ  ì‹¤íŒ¨:', error);
      // ì‚¬ìš©ìê°€ ê³µìœ ë¥¼ ì·¨ì†Œí•œ ê²½ìš°ëŠ” ì—ëŸ¬ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      if (error instanceof Error && error.name === 'AbortError') {
        return false;
      }
      throw error;
    }
  }

  /**
   * ê³µìœ ëœ ì ê´˜ ì¡°íšŒ
   */
  async getSharedReading(shareId: string): Promise<SharedReading | null> {
    try {
      const { data, error } = await supabase
        .from('shared_readings')
        .select('*')
        .eq('id', shareId)
        .single();
      
      if (error) {
        console.error('Error fetching shared reading:', error);
        return null;
      }
      
      // ë§Œë£Œ ì²´í¬
      if (new Date(data.expires_at) < new Date()) {
        console.log('Shared reading has expired');
        return null;
      }
      
      return {
        id: data.id,
        createdAt: new Date(data.created_at),
        expiresAt: new Date(data.expires_at),
        spreadType: data.spread_type,
        cards: data.cards,
        customQuestion: data.custom_question,
        basicInterpretation: data.basic_interpretation,
        aiInterpretation: data.ai_interpretation,
        sharedBy: data.shared_by,
        viewCount: data.view_count
      };
      
    } catch (error) {
      console.error('ê³µìœ  ì ê´˜ ì¡°íšŒ ì‹¤íŒ¨:', error);
      return null;
    }
  }

  /**
   * í¬ì§€ì…˜ ì´ë¦„ ê°€ì ¸ì˜¤ê¸° í—¬í¼
   */
  private getPositionName(spreadId: string, index: number): string {
    const positions: Record<string, string[]> = {
      'three_card_timeline': ['ê³¼ê±°', 'í˜„ì¬', 'ë¯¸ë˜'],
      'celtic_cross': [
        'í˜„ì¬ ë‚´ë©´', 'í˜„ì¬ ì™¸ë¶€', 'ê·¼ë³¸', 'ê³¼ê±°',
        'ë“œëŸ¬ë‚˜ëŠ” ëª¨ìŠµ', 'ë¯¸ë˜', 'ë‚´ê°€ ë³´ëŠ” ë‚˜',
        'ë‚¨ì´ ë³´ëŠ” ë‚˜', 'ì˜ˆìƒí•˜ëŠ” ê²°ê³¼', 'ì‹¤ì œ ê²°ê³¼'
      ]
    };
    
    return positions[spreadId]?.[index] || `ì¹´ë“œ ${index + 1}`;
  }

  /**
   * ì˜¤ëŠ˜ì˜ ì¹´ë“œ í•´ì„ì„ í…ìŠ¤íŠ¸ë¡œ í¬ë§·íŒ…
   */
  private formatDailyInterpretation(interpretation: DailyInterpretation): string {
    let text = '';
    
    // ìš´ì„¸ ì§€ìˆ˜
    if (interpretation.fortuneIndex) {
      text += 'ğŸ“Š ì˜¤ëŠ˜ì˜ ìš´ì„¸ ì§€ìˆ˜\n';
      for (const [key, value] of Object.entries(interpretation.fortuneIndex)) {
        const label = this.getFortuneLabel(key);
        text += `${label}: ${'â­'.repeat(value)}\n`;
      }
      text += '\n';
    }
    
    // ìƒì„¸ ìš´ì„¸
    if (interpretation.detailedFortune) {
      text += 'ğŸ”® ì˜¤ëŠ˜ì˜ ë©”ì‹œì§€\n';
      text += interpretation.detailedFortune.mainMessage + '\n\n';
      
      if (interpretation.detailedFortune.keyPoint) {
        text += `ğŸ’« í•µì‹¬ í¬ì¸íŠ¸: ${interpretation.detailedFortune.keyPoint}\n`;
      }
      if (interpretation.detailedFortune.advice) {
        text += `ğŸ’¡ ì¡°ì–¸: ${interpretation.detailedFortune.advice}\n`;
      }
    }
    
    return text;
  }

  private getFortuneLabel(key: string): string {
    const labels: Record<string, string> = {
      overall: 'ì „ì²´ìš´',
      love: 'ì• ì •ìš´',
      money: 'ê¸ˆì „ìš´',
      health: 'ê±´ê°•ìš´',
      work: 'í•™ì—…/ì—…ë¬´ìš´'
    };
    return labels[key] || key;
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const shareService = new ShareServiceWeb();
